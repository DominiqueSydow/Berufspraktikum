#---------------------------------------------------------------------------------------------#
#Purpose:
#    to parse through the result-files and the qgram-files generated by 'probe-generator'
#    in order to find sequences in q-gram-files which do not appear in the match-list (between pattern and genome) generated by 'probe-generator'
#
#Authors:#    Martin Seeger, Matthias Schade
#---------------------------------------------------------------------------------------------#

import os
#import re
from dircache import listdir
import collections
import pickle
#import numpy as np
#import matplotlib.pylab as pl #import pylab as pl

#---------------------------------------------#
# CONSTANTS
#---------------------------------------------#
#Create artificial q-gram-list listing all probes of length n from a particular virus segment
#qgramindexlist = range(0, 1000)

#Input folders:
#    -from the pattern (e.g. virus) a list of n-grams is created to be matched against the genome (e.g. host)
#    -the genome is used for targeting each of the n-grams against
# attention: switch "\" by "/" due to OS
folder_pattern = "D:/Eigene Dateien matthias/workspace/MyTestProject/mynewPythonPackage/pattern/"
folder_genome = "D:/Eigene Dateien matthias/workspace/MyTestProject/mynewPythonPackage/genome/"

#Filter: name-ending of files containing original qgrams:
filter_qgramfile = "_qgrams.fa"
#Filter: name-ending of files containing results of razerS-alignment (where pattern matches with target genome):
filter_results = ".result"
#Analysis saving name
fname_pPP = "pPP"
picForm = ".dat"

def create_qgramIndex_list(allfiles):
    #qgramindexlist=[]
    qgramindexlist={}
    m=0
    #User feedback
    print "\nSTARTING: Creation of qgramIndexList for all source patterns ..."
    #get a list of all files in the current working directory of python
    #allfiles = listdir(os.getcwd())

    for myFile in allfiles:
        #consider only those files which end the filter-string specified
        if not myFile.endswith(filter_qgramfile): continue
        #open each file as "read only"
        with open(myFile, "r") as f:
            m=m+1
            #print "reading in ", myFile
            for line in f:
                #print "length: ", len(qgramindexlist)
                #in each file and each line get the first 'word' only 
                #print "linsplit: ", line.split()
                firstword = line.split()[0]
                #print "firstword: ", firstword
                #print "firstword[ohne ersten Buchstaben]: ", firstword[1:]
                #
                if firstword[0]==">":
                    strPos = firstword[1:] #Zwischenspreichern
                else:
                    strSeq = firstword[1:] #Zwischenspeichern
                    #print len(qgramindexlist)
                    #print "strPos: ", strPos, "strSeq: ", strSeq
                    #qgramindexlist.append((strPos, strSeq))
                    qgramindexlist[strPos] = strSeq
                    strPos=""
                    strSeq=""
    print " DONE: qgramIndexList completed for "+str(m)+" file(s), containing a total of " + str(len(qgramindexlist)) +" elements."
    return qgramindexlist

def remove_qGramsByHost(allfiles,qGramIndexKeys):
    '''
    Removes all qgrams from qGramIndexKeys which were found to also exist in the host genome
    by parameters (identity, rr) specified for razerS
    '''
    
    nInitial = len(qGramIndexKeys)
    
    #------------------------#
    #User feedback
    #------------------------#
    print "\nSTARTING: Removal of qgrams which were found to also exist in the host genome. Starting with "+str(nInitial)+" qgrams ..."
    resultsIndexKeys=[]
    for myFile in allfiles:
        #consider only those files which end the filter-string specified
        if not myFile.endswith(filter_results): continue
        #open each file as "read only"
        with open(myFile, "r") as f:
            #print "reading in ", myFile
            for line in f:
                #print "length: ", len(qgramindexlist)
                #in each file and each line get the first 'word' only 
                #print "linsplit: ", line.split()
                firstword = line.split()[0]
                resultsIndexKeys.append(firstword)
    #reduce results down to unique entries
    resultSet = set(resultsIndexKeys) 
    #remove sequences from the qgramindex, leaving only those sequences for which raszers did not return a match between virus and host-genome
    #print "qGramIndexKeys before: ", len(qGramIndexKeys)
    #print "resultSet before: ", len(resultSet)
    #print "qGramIndexKeys before: ", qGramIndexKeys
    #print "resultSet before: ", resultSet
    qGramIndexKeys = qGramIndexKeys-resultSet
    #print "qgramindexlist after: ", len(qGramIndexKeys)

    #------------------------#
    #User feedback
    #------------------------#  
    nEnd = len(qGramIndexKeys)
    print " DONE: "+str(nInitial-nEnd)+" qgrams removed, leaving "+str(nEnd)+" qgrams."
    
    return qGramIndexKeys


def find_key(dic, val):
    """return the key of dictionary dic given the value"""
    #COMMENT: actually, positive case (existance of multiples) never tested!!!!
    return [k for k, v in dic.iteritems() if v == val][0]


def get_multipleHitsInPattern(qGramIndexDict):
    #COMMENT: actually, positive case (existance of multiples) never tested!!!!
    multiSeqPos=[]
    print "\nSTARTING: Checking for sequence-doubles or -multiples in source pattern."
    #extract all sequences from dict
    seqList = qGramIndexDict.values()
    if len(seqList)> len(set(seqList)):
        print "\tSequence-doubles or -multiples found. Extracting sequences ..."
        #create statistic on occurrences of values in list
        y=collections.Counter(seqList)
        #sequences, which occur more than once
        multiSeqs = [i for i in y if y[i]>1]
        print "\t " +str(len(multiSeqs))+" sequences occur more than once."
        #Positions of sequences which occur more than once
        #multiSeqPos = [j in qGramIndexDict ]
        multiSeqPos = find_key(qGramIndexDict, multiSeqs)
        print "\t Corresponding positions: ",  multiSeqPos
    else:
        print " DONE: No sequence-doubles or -multiples found."    

    return multiSeqPos



def get2DArrayOfNonHitsInTargetGenome(qGramIndexDict,folder_pattern):
    #DESCIPTION: returns a 2D-array: for each source pattern the is a list of non-hits
    # e.g.: {[segment1: (452, 578, 323, 676)], [segment4: (2, 676)]}
    
    positiveProbePositions = {}
    
    #Read in all files in the patter directory
    patternfiles = listdir(folder_pattern)
    
    #strip file-type ending
    patternFileNames = [x[:-3] for x in patternfiles]
    #print "patternfileNames: ", patternFileNames
    
    #------------------------#
    #User feedback
    #------------------------#
    print "\nSTARTING: extracting probe starting positions relative to source pattern for each source pattern."
    #print "len(qGramIndexDict): ", len(qGramIndexDict)
    for p in patternFileNames:
        miniSeqP = []
        for q in qGramIndexDict:
            #print "q: ", q
            #print "patternfileNames: ", p
            #print "q.find(patternfileNames): ", q.find(p)
            
            #only if the pattern name can be identified:
            if (q.find(p)>-1):
                #get the sequence position, which is walled in between "(" and ":":
                mySubString=q[q.find("(")+1:q.find(":")]
                #append position
                miniSeqP.append(int(mySubString))
                #print "mySubString: ", mySubString
                
                #print str(q(srt:end))
                #seqPosition.append(int(q(srt:end)))
        #flush sequence positions into larger "array"
        miniSeqP.sort()
        positiveProbePositions[p]=miniSeqP
    
    print " DONE: extracting probe starting positions."
    
    return positiveProbePositions

def loadpPP(fname,picForm):
    #DESCRIPTION:
    #    load settings as a pickle from a specified filename
    fileobj = open(fname+picForm,'r')
    pPP = pickle.load(fileobj)
    fileobj.close()

    return pPP

def savepPP(pPP,fname, picForm):
    #DESCRIPTION:
    #    store settings as a pickle under a specified filename
    
    fileobj = open (fname+picForm,'w')
    success = pickle.dump(pPP,fileobj)
    fileobj.close()
    
    print "\n --> Results saved as: "+ fname_pPP
    
    return success
    
def visualizepositiveProbePositions(pPP):
    # Make an array of x values
    x = [1, 2, 3, 4, 5]
    # Make an array of y values for each x value
    y = [1, 4, 9, 16, 25]
    # use pylab to plot x and y
    #pl.plot(x, y)
    # show the plot on the screen
    #pl.show()
    return


#---------------------------------------------#
# MAIN CODE
#---------------------------------------------#
if __name__=="__main__":
    
    #------------------------#
    #User feedback
    #------------------------#
    print "\n--------------------------------\n   WELCOME to non-match-finder\n--------------------------------"
    
    #get a list of all files in the current working directory of python
    allfiles = listdir(os.getcwd())
    
    #create a full list of all qgrams of all pattern
    qGramIndexDict = create_qgramIndex_list(allfiles)

    #extract only names without Sequences and reduce it to unique entries (probably unnecessary)
    qGramIndexKeys = set(qGramIndexDict.keys()) #qGramIndexListOnly = [qGramIndexListWithSeq[i][0] for i in range(0, len(qGramIndexListWithSeq) -1)]
        
    #remove all qgramEntries which exist both in source-pattern and in target-genome
    qGramIndexKeys_purged = remove_qGramsByHost(allfiles, qGramIndexKeys)
    
    #reduce dict down to sequences which were NOT found to exit in the target-genome (and thus are usable for probe-building
    #print "before: ", len(qGramIndexDict)
    [qGramIndexDict.pop(key) for key in qGramIndexKeys_purged]
    #print "after: ", len(qGramIndexDict)
    
    #check if the current qGramIndexDict contains the same sequence twice
    multipleHitsInPattern = get_multipleHitsInPattern(qGramIndexDict)
    
    #get 2D-array of non-hits for each source pattern
    positiveProbePositions = get2DArrayOfNonHitsInTargetGenome(qGramIndexDict,folder_pattern)    
    
    #saving Results before attempting to visualize them
    savepPP(positiveProbePositions, fname_pPP,picForm)
    
    #create scatter plots for each segment
    #visualizepositiveProbePositions(positiveProbePositions)
    
        
    print "\n", positiveProbePositions
    
 









    
#    #get a list of all files in the current working directory of python
#    resultfiles = listdir(os.getcwd())
#
#    for resultfile in resultfiles:
#        #consider only those files which end in ".result"
#        if not resultfile.endswith(".result"): continue
#        #open each file as "read only"
#        with open(resultfile, "r") as f:
#            print "reading in ", resultfile
#            for line in f:
#                #in each file and each line get a list of first words only (e.g. "read_045"
#                print line.split()
#                firstword = line.split()[0]
#                
#                #extract only numbers for the list of all first words
#                matchingindex = int(re.findall(r'\d+', firstword)[0])
#                print matchingindex
#                #remove all numbers from the q-gram-index, leaving only those sequences for which raszers did not return a match between virus and host-genome
#                qgramindexlist.remove(matchingindex)
#
#    print qgramindexlist
#    print len(qgramindexlist)
    
    